import { logWarningSprintf, valueToHex } from '../utils/utils';
import { FSFlag } from './FsFlags';
import { GET_FLAG, GET_FLAG_NOT_FOUND } from '../enum/FlagshipConstant';
/**
 * Represents a collection of flags.
 */
export class FSFlagCollection {
    _visitor;
    _keys = new Set();
    _flags;
    /**
       * Creates a new instance of FSFlagCollection.
       * @param param - The parameter object.
       * @param param.visitor - The visitor delegate.
       * @param param.flags - The initial flags.
       */
    constructor(param) {
        const { visitor, flags } = param;
        this._visitor = visitor;
        this._flags = flags || new Map();
        if (this._flags.size === 0) {
            this._keys = new Set(visitor?.flagsData.keys());
            this._keys.forEach((key) => {
                this._flags.set(key, new FSFlag({ key, visitor }));
            });
        }
        else {
            this._keys = new Set(this._flags.keys());
        }
    }
    /**
     * @inheritdoc
     */
    get size() {
        return this._keys.size;
    }
    /**
     * @inheritdoc
     */
    get(key) {
        const flag = this._flags.get(key);
        if (!flag) {
            this._visitor?.config && logWarningSprintf(this._visitor?.config, GET_FLAG, GET_FLAG_NOT_FOUND, this._visitor?.visitorId, key);
            return new FSFlag({ key });
        }
        return flag;
    }
    /**
     * @inheritdoc
     */
    has(key) {
        return this._keys.has(key);
    }
    /**
     * @inheritdoc
     */
    keys() {
        return this._keys;
    }
    /**
     * @inheritdoc
     */
    [Symbol.iterator]() {
        let index = 0;
        const keysArray = Array.from(this._keys);
        return {
            next: () => {
                if (index < keysArray.length) {
                    const key = keysArray[index++];
                    return { value: [key, this._flags.get(key)], done: false };
                }
                else {
                    return { value: null, done: true };
                }
            }
        };
    }
    /**
     * @inheritdoc
     */
    filter(predicate) {
        const flags = new Map();
        this._flags.forEach((flag, key) => {
            if (predicate(flag, key, this)) {
                flags.set(key, flag);
            }
        });
        return new FSFlagCollection({ visitor: this._visitor, flags });
    }
    /**
     * @inheritdoc
     */
    async exposeAll() {
        await Promise.all(Array.from(this._flags.values(), (flag) => flag.visitorExposed()));
    }
    /**
     * @inheritdoc
     */
    getMetadata() {
        const metadata = new Map();
        this._flags.forEach((flag, key) => {
            metadata.set(key, flag.metadata);
        });
        return metadata;
    }
    /**
     * @inheritdoc
     */
    toJSON() {
        const serializedData = [];
        this._flags.forEach((flag, key) => {
            const metadata = flag.metadata;
            serializedData.push({
                key,
                campaignId: metadata.campaignId,
                campaignName: metadata.campaignName,
                variationGroupId: metadata.variationGroupId,
                variationGroupName: metadata.variationGroupName,
                variationId: metadata.variationId,
                variationName: metadata.variationName,
                isReference: metadata.isReference,
                campaignType: metadata.campaignType,
                slug: metadata.slug,
                hex: valueToHex({ v: flag.getValue(null, false) })
            });
        });
        return serializedData;
    }
    forEach(callbackfn) {
        this._flags.forEach((flag, key) => {
            callbackfn(flag, key, this);
        });
    }
}
