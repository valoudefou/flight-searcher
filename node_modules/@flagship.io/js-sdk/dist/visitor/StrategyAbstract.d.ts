import { HitAbstract } from '../hit/index';
import { primitive, IHit, VisitorCacheDTO, IFSFlagMetadata, CampaignDTO } from '../types';
import { IVisitor } from './IVisitor';
import { VisitorAbstract } from './VisitorAbstract';
import { DecisionMode, IConfigManager, IFlagshipConfig } from '../config/index';
import { IDecisionManager } from '../decision/IDecisionManager';
import { BatchDTO } from '../hit/Batch';
import { ITrackingManager } from '../api/ITrackingManager';
import { Troubleshooting } from '../hit/Troubleshooting';
import { MurmurHash } from '../utils/MurmurHash';
import { GetFlagMetadataParam, GetFlagValueParam, VisitorExposedParam } from '../type.local';
export declare const LOOKUP_HITS_JSON_ERROR = "JSON DATA must be an array of object";
export declare const LOOKUP_HITS_JSON_OBJECT_ERROR = "JSON DATA must fit the type HitCacheDTO";
export declare const VISITOR_ID_MISMATCH_ERROR = "Visitor ID mismatch: {0} vs {1}";
export type StrategyAbstractConstruct = {
    visitor: VisitorAbstract;
    murmurHash: MurmurHash;
};
export declare abstract class StrategyAbstract implements Omit<IVisitor, 'visitorId' | 'anonymousId' | 'fetchStatus' | 'flagsData' | 'context' | 'hasConsented' | 'getFlagsDataArray' | 'getFlag' | 'getFlags'> {
    protected visitor: VisitorAbstract;
    protected get configManager(): IConfigManager;
    protected get trackingManager(): ITrackingManager;
    protected get decisionManager(): IDecisionManager;
    get config(): IFlagshipConfig;
    protected _murmurHash: MurmurHash;
    constructor(param: StrategyAbstractConstruct);
    updateCampaigns(campaigns: CampaignDTO[]): void;
    protected hasTrackingManager(process: string): boolean;
    setConsent(hasConsented: boolean): void;
    protected checKLookupVisitorDataV1(item: VisitorCacheDTO): boolean;
    protected checKLookupVisitorData(item: VisitorCacheDTO): boolean;
    lookupVisitor(): Promise<void>;
    cacheVisitor(): Promise<void>;
    protected flushVisitor(): Promise<void>;
    abstract updateContext(key: string, value: primitive): void;
    abstract updateContext(context: Record<string, primitive>): void;
    abstract updateContext(context: Record<string, primitive> | string, value?: primitive): void;
    abstract clearContext(): void;
    abstract sendHit(hit: HitAbstract): Promise<void>;
    abstract sendHit(hit: IHit): Promise<void>;
    abstract sendHit(hit: IHit | HitAbstract | BatchDTO): Promise<void>;
    abstract sendHits(hit: HitAbstract[]): Promise<void>;
    abstract sendHits(hit: IHit[]): Promise<void>;
    abstract sendHits(hits: HitAbstract[] | IHit[] | BatchDTO[]): Promise<void>;
    abstract authenticate(visitorId: string): void;
    abstract unauthenticate(): void;
    abstract fetchFlags(): Promise<void>;
    abstract visitorExposed(param: VisitorExposedParam): Promise<void>;
    abstract getFlagValue<T>(param: GetFlagValueParam<T>): T extends null ? unknown : T;
    abstract getFlagMetadata(param: GetFlagMetadataParam): IFSFlagMetadata;
    sendTroubleshootingHit(hit: Troubleshooting): Promise<void>;
    getCurrentDateTime(): Date;
    protected getSdkConfigDecisionMode(): DecisionMode.BUCKETING | DecisionMode.BUCKETING_EDGE | "DECISION_API" | undefined;
    sendSdkConfigAnalyticHit(): Promise<void>;
    sendFetchFlagsTroubleshooting({ isFromCache, campaigns, now }: {
        isFromCache: boolean;
        campaigns: CampaignDTO[];
        now: number;
    }): void;
    sendConsentHitTroubleshooting(): void;
    sendSegmentHitTroubleshooting(): void;
}
